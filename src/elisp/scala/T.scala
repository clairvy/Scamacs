trait A 

class Point (x: Int, 
 z: Int, 
 y: Int) extends {x = 2; y = 4} with A (x:Int, y: Int) {
val f () = (x:Int) => x + 1
def f () = 3
object X extends {x = 3} {
def f = 2
val y = 2
}

class P (x: Int = 3) {
val x = 3
}
val y = 2

def total () = x + y
}

object T {

object S {
}

def min (x: Int, y: Int) =
if (x < y) {
x 
} else {
y
}

def switch (i: Int) =
i match {
case 2 => 
3 match {
case 3 => {
3 match {
case x => {
3
4
}
case y => 5
}
case x => 
0
3
case y => 2
}
case 5 =>
dothat
andthis and that
doanother
case 6 =>
dothat
andthis
doanother 
}
case 4 => 5
case 5 => 5
}

def f (g: Int => Int) = {
for (x <- xs) yield {
g (3)
}
}
}

;; fails, but would fixing violate my do no evil pledge?
object X {

T.f { x => 
println ("X: " + x)
println ("Y: " + x)
x
}

object X {
def f = T.f { x => {
println ("X: " + x)
x
}
}
}

}

class X {
val x = 3

def g = T.f { x => {
println ("X: " + x) 
x
f (y, x)
}
}
}

object X { 
x
2
val x = 3
x
y
{
3
2
}
}
